# 在 Go 语言中使用 PostgreSQL

## `jackc/pgx`

Github 地址：
https://github.com/jackc/pgx

Wiki 地址：
https://github.com/jackc/pgx/wiki

- `jackc/pgx` 是目前 Go 生态中 PostgreSQL 相关库的事实标准，GitHub 星标数超过 15k，下载量稳居前列。
- 从社区反馈看，`pgx`  凭借以下优势成为最受欢迎的选择：
  - 性能远超  `lib/pq`（原生接口模式下吞吐量提升 30%+）；
  - 对 PostgreSQL 特有功能（如数组、枚举、地理信息类型）支持完善；
  - 内置连接池、自动重连等生产级特性；
  - 详细的文档和丰富的示例，降低使用门槛。
- 提供两种使用方式：
  - 兼容  `database/sql`  接口（通过  `pgx/stdlib`  子包），便于迁移现有项目；
  - 原生接口（`pgx`核心包），性能更优，支持更多 PostgreSQL 高级特性（如异步查询、COPY 协议、JSON 类型等）。
- 维护活跃，对 PostgreSQL 新特性支持及时（如 14/15 版本的语法和功能）。

```go
package main

import (
	"context"
	"fmt"
	"os"

	"github.com/jackc/pgx/v5"
)

func main() {
	// urlExample := "postgres://username:password@localhost:5432/database_name"
	conn, err := pgx.Connect(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close(context.Background())

	var name string
	var weight int64
	err = conn.QueryRow(context.Background(), "select name, weight from widgets where id=$1", 42).Scan(&name, &weight)
	if err != nil {
		fmt.Fprintf(os.Stderr, "QueryRow failed: %v\n", err)
		os.Exit(1)
	}

	fmt.Println(name, weight)
}
```

## pgx (v5 版本) 使用指南与示例

jackc/pgx 是 Go 语言中操作 PostgreSQL 的高性能驱动，v5 版本是目前的最新稳定版，提供了更简洁的 API 和更好的性能。下面是完整的使用示例和注意事项。

### 一、基础配置与连接

首先需要安装依赖：

```bash
go get github.com/jackc/pgx/v5/pgxpool
go get github.com/jackc/pgx/v5
```

```go
import (
	"github.com/jackc/pgx/v5/pgxpool"
)

// 全局连接池
var dbPool *pgxpool.Pool

// 初始化数据库连接池
func initDB() error {
	// 连接字符串格式: postgresql://user:password@host:port/dbname?sslmode=disable
	connString := "postgresql://postgres:your_password@localhost:5432/ecommerce_test?sslmode=disable"

	// 解析配置
	cfg, err := pgxpool.ParseConfig(connString)
	if err != nil {
		return fmt.Errorf("无法解析连接字符串: %v", err)
	}

	// 可以设置连接池参数
	cfg.MaxConns = 20 // 最大连接数

	// 创建连接池
	dbPool, err = pgxpool.NewWithConfig(context.Background(), cfg)
	if err != nil {
		return fmt.Errorf("无法创建连接池: %v", err)
	}

	// 测试连接
	err = dbPool.Ping(context.Background())
	if err != nil {
		return fmt.Errorf("连接数据库失败: %v", err)
	}

	log.Println("数据库连接成功")
	return nil
}

func main() {
	// 初始化数据库连接
	if err := initDB(); err != nil {
		log.Fatalf("初始化数据库失败: %v", err)
	}
	defer dbPool.Close() // 程序退出时关闭连接池

	// 后续操作...
}

```

### 二、基础增删改查示例

```go
import (
	"github.com/jackc/pgx/v5"
)

// User 结构体对应数据库users表
type User struct {
	UserID    int
	Username  string
	Email     string
	CreatedAt time.Time
	Country   string
	Age       int
}

// 1. 查询操作 (SELECT)
func getUserByID(userID int) (*User, error) {
	query := `
		SELECT user_id, username, email, created_at, country, age
		FROM users
		WHERE user_id = $1
	`

	var user User
	// 执行查询
	err := dbPool.QueryRow(context.Background(), query, userID).Scan(
		&user.UserID,
		&user.Username,
		&user.Email,
		&user.CreatedAt,
		&user.Country,
		&user.Age,
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("未找到ID为%d的用户", userID)
		}
		return nil, fmt.Errorf("查询用户失败: %v", err)
	}

	return &user, nil
}

// 2. 插入操作 (INSERT)
func createUser(username, email, country string, age int) (int, error) {
	query := `
		INSERT INTO users (username, email, country, age)
		VALUES ($1, $2, $3, $4)
		RETURNING user_id
	`

	var newUserID int
	// 执行插入并返回生成的ID
	err := dbPool.QueryRow(
		context.Background(),
		query,
		username,
		email,
		country,
		age,
	).Scan(&newUserID)

	if err != nil {
		return 0, fmt.Errorf("创建用户失败: %v", err)
	}

	return newUserID, nil
}

// 3. 更新操作 (UPDATE)
func updateUserAge(userID int, newAge int) error {
	query := `
		UPDATE users
		SET age = $1
		WHERE user_id = $2
	`

	// 执行更新
	result, err := dbPool.Exec(context.Background(), query, newAge, userID)
	if err != nil {
		return fmt.Errorf("更新用户年龄失败: %v", err)
	}

	// 检查是否有行被更新
	if result.RowsAffected() == 0 {
		return fmt.Errorf("未找到ID为%d的用户", userID)
	}

	return nil
}

// 4. 删除操作 (DELETE)
func deleteUser(userID int) error {
	query := `DELETE FROM users WHERE user_id = $1`

	result, err := dbPool.Exec(context.Background(), query, userID)
	if err != nil {
		return fmt.Errorf("删除用户失败: %v", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("未找到ID为%d的用户", userID)
	}

	return nil
}

// 批量查询示例
func getUsersByCountry(country string) ([]User, error) {
	query := `
		SELECT user_id, username, email, created_at, country, age
		FROM users
		WHERE country = $1
		ORDER BY username
	`

	// 执行查询获取多行结果
	rows, err := dbPool.Query(context.Background(), query, country)
	if err != nil {
		return nil, fmt.Errorf("查询用户失败: %v", err)
	}
	defer rows.Close() // 确保rows被关闭

	var users []User
	// 迭代结果集
	for rows.Next() {
		var user User
		err := rows.Scan(
			&user.UserID,
			&user.Username,
			&user.Email,
			&user.CreatedAt,
			&user.Country,
			&user.Age,
		)
		if err != nil {
			return nil, fmt.Errorf("扫描用户数据失败: %v", err)
		}
		users = append(users, user)
	}

	// 检查迭代过程中是否发生错误
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows迭代错误: %v", err)
	}

	return users, nil
}

// 在main函数中测试CRUD操作
func testCRUD() {
	// 创建用户
	newUserID, err := createUser("test_user", "test@example.com", "USA", 30)
	if err != nil {
		log.Printf("创建用户失败: %v", err)
	} else {
		log.Printf("创建用户成功，ID: %d", newUserID)
	}

	// 查询用户
	user, err := getUserByID(newUserID)
	if err != nil {
		log.Printf("查询用户失败: %v", err)
	} else {
		log.Printf("查询到用户: %+v", user)
	}

	// 更新用户
	err = updateUserAge(newUserID, 31)
	if err != nil {
		log.Printf("更新用户失败: %v", err)
	} else {
		log.Println("更新用户年龄成功")
	}

	// 批量查询
	users, err := getUsersByCountry("USA")
	if err != nil {
		log.Printf("批量查询失败: %v", err)
	} else {
		log.Printf("美国用户列表: %+v", users)
	}

	// 删除用户
	err = deleteUser(newUserID)
	if err != nil {
		log.Printf("删除用户失败: %v", err)
	} else {
		log.Println("删除用户成功")
	}
}

```

### 三、之前 SQL 练习题的 pgx 实现

```go
// 1. 查询所有用户的用户名和所在国家，按国家字母顺序排序
func exercise1() {
	query := `
		SELECT username, country
		FROM users
		ORDER BY country
	`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("练习1结果:")
	for rows.Next() {
		var username, country string
		err := rows.Scan(&username, &country)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("用户名: %-10s 国家: %s\n", username, country)
	}
}

// 2. 查询价格在50到100之间的产品名称和价格
func exercise2() {
	query := `
		SELECT product_name, price
		FROM products
		WHERE price BETWEEN $1 AND $2
	`

	rows, err := dbPool.Query(context.Background(), query, 50, 100)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习2结果:")
	for rows.Next() {
		var productName string
		var price float64
		err := rows.Scan(&productName, &price)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("产品: %-20s 价格: $%.2f\n", productName, price)
	}
}

// 3. 统计每个国家的用户数量
func exercise3() {
	query := `
		SELECT country, COUNT(*) AS user_count
		FROM users
		GROUP BY country
		ORDER BY user_count DESC
	`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习3结果:")
	for rows.Next() {
		var country string
		var count int
		err := rows.Scan(&country, &count)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("国家: %-10s 用户数量: %d\n", country, count)
	}
}

// 4. 查询所有订单，显示订单ID、用户名和订单状态
func exercise4() {
	query := `
		SELECT o.order_id, u.username, o.status
		FROM orders o
		JOIN users u ON o.user_id = u.user_id
	`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习4结果:")
	for rows.Next() {
		var orderID int
		var username, status string
		err := rows.Scan(&orderID, &username, &status)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("订单ID: %-5d 用户名: %-10s 状态: %s\n", orderID, username, status)
	}
}

// 5. 查询每个订单包含的产品名称和数量
func exercise5() {
	query := `
		SELECT o.order_id, p.product_name, oi.quantity
		FROM order_items oi
		JOIN orders o ON oi.order_id = o.order_id
		JOIN products p ON oi.product_id = p.product_id
		ORDER BY o.order_id
	`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习5结果:")
	for rows.Next() {
		var orderID, quantity int
		var productName string
		err := rows.Scan(&orderID, &productName, &quantity)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("订单ID: %-5d 产品: %-20s 数量: %d\n", orderID, productName, quantity)
	}
}

// 6. 查询总金额大于1000的订单及其用户信息
func exercise6() {
	query := `
		SELECT o.order_id, u.username, o.total_amount, o.order_date
		FROM orders o
		JOIN users u ON o.user_id = u.user_id
		WHERE o.total_amount > $1
		ORDER BY o.total_amount DESC
	`

	rows, err := dbPool.Query(context.Background(), query, 1000)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习6结果:")
	for rows.Next() {
		var orderID int
		var username string
		var totalAmount float64
		var orderDate time.Time
		err := rows.Scan(&orderID, &username, &totalAmount, &orderDate)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("订单ID: %-5d 用户名: %-10s 金额: $%.2f 日期: %s\n",
			orderID, username, totalAmount, orderDate.Format("2006-01-02"))
	}
}

// 7. 计算每个类别的产品平均价格
func exercise7() {
	query := `
		SELECT category, AVG(price) AS avg_price
		FROM products
		GROUP BY category
		ORDER BY avg_price DESC
	`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		log.Printf("查询失败: %v", err)
		return
	}
	defer rows.Close()

	fmt.Println("\n练习7结果:")
	for rows.Next() {
		var category string
		var avgPrice float64
		err := rows.Scan(&category, &avgPrice)
		if err != nil {
			log.Printf("扫描失败: %v", err)
			return
		}
		fmt.Printf("类别: %-15s 平均价格: $%.2f\n", category, avgPrice)
	}
}

// 在main函数中调用练习函数
func runExercises() {
	exercise1()
	exercise2()
	exercise3()
	exercise4()
	exercise5()
	exercise6()
	exercise7()
	// 可以继续实现其他练习...
}

```

### 四、事务处理示例

```go
// 模拟用户购买产品的事务
func purchaseProduct(userID, productID, quantity int) (int, error) {
	// 开始事务
	tx, err := dbPool.Begin(context.Background())
	if err != nil {
		return 0, fmt.Errorf("无法开始事务: %v", err)
	}
	defer func() {
		// 如果事务没有提交，则回滚
		if r := recover(); r != nil {
			tx.Rollback(context.Background())
		}
	}()

	// 1. 查询产品信息和库存
	var productName string
	var price float64
	var stock int
	query := "SELECT product_name, price, stock_quantity FROM products WHERE product_id = $1"
	err = tx.QueryRow(context.Background(), query, productID).Scan(&productName, &price, &stock)
	if err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("查询产品失败: %v", err)
	}

	// 检查库存是否充足
	if stock < quantity {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("库存不足，当前库存: %d, 请求数量: %d", stock, quantity)
	}

	// 2. 创建订单
	var orderID int
	orderTotal := price * float64(quantity)
	query = "INSERT INTO orders (user_id, total_amount, status) VALUES ($1, $2, 'pending') RETURNING order_id"
	err = tx.QueryRow(context.Background(), query, userID, orderTotal).Scan(&orderID)
	if err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("创建订单失败: %v", err)
	}

	// 3. 创建订单项
	query = "INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES ($1, $2, $3, $4)"
	_, err = tx.Exec(context.Background(), query, orderID, productID, quantity, price)
	if err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("创建订单项失败: %v", err)
	}

	// 4. 更新库存
	query = "UPDATE products SET stock_quantity = stock_quantity - $1 WHERE product_id = $2"
	_, err = tx.Exec(context.Background(), query, quantity, productID)
	if err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("更新库存失败: %v", err)
	}

	// 5. 确认订单状态
	query = "UPDATE orders SET status = 'completed' WHERE order_id = $1"
	_, err = tx.Exec(context.Background(), query, orderID)
	if err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("更新订单状态失败: %v", err)
	}

	// 提交事务
	if err := tx.Commit(context.Background()); err != nil {
		tx.Rollback(context.Background())
		return 0, fmt.Errorf("提交事务失败: %v", err)
	}

	log.Printf("购买成功，订单ID: %d, 产品: %s, 数量: %d, 总价: $%.2f",
		orderID, productName, quantity, orderTotal)
	return orderID, nil
}

```

### 五、pgx 使用注意事项

1. **连接池管理**

   - 总是使用  `pgxpool`  而不是单个连接，它会自动管理连接复用
   - 根据服务器性能合理设置  `MaxConns`，通常建议为 CPU 核心数的 2-4 倍
   - 程序退出时务必调用  `dbPool.Close()`  释放资源

2. **参数绑定**

   - 始终使用参数化查询（`$1, $2`  占位符），不要拼接 SQL 字符串，防止 SQL 注入
   - pgx 使用  `$n`  而不是  `?`  作为参数占位符，注意与其他库的区别

3. **错误处理**

   - 检查  `pgx.ErrNoRows`  来判断是否查询到数据，而不是依赖返回值是否为 nil
   - 所有数据库操作都要处理错误，不要忽略任何可能的错误

4. **资源释放**

   - `Query`  方法返回的  `pgx.Rows`  必须关闭，通常使用  `defer rows.Close()`
   - 事务要么提交要么回滚，避免长时间未完成的事务

5. **上下文使用**

   - 总是传递  `context.Context`  参数，便于实现超时控制和请求取消
   - 示例：`context.WithTimeout(context.Background(), 5*time.Second)`

6. **数据类型映射**

   - PostgreSQL 的  `timestamp`  对应 Go 的  `time.Time`
   - PostgreSQL 的  `numeric`  对应 Go 的  `float64`  或  `*big.Rat`
   - 可以使用  `pgtype`  包处理更复杂的类型映射

7. **性能优化**

   - 批量操作使用  `CopyFrom`  而不是多次  `INSERT`
   - 复杂查询考虑使用预编译语句（`Prepare`）
   - 适当使用连接池的  `Acquire`  方法获取连接进行多个连续操作

8. **版本兼容性**

   - pgx v5 与 v4 有较大 API 差异，确保文档和示例对应正确版本
   - 定期更新 pgx 到最新版本，获取性能改进和安全修复

通过以上示例和注意事项，你可以开始使用 pgx 进行实际项目开发了。建议先从简单的 CRUD 操作开始，逐步掌握事务、批量操作等高级特性。

## 避免重复使用连接池

在使用  `jackc/pgx`  操作 PostgreSQL 时，**不需要重复创建连接**，反而应尽量复用连接（或通过连接池管理连接），否则会严重影响性能。

### 核心原因：

建立数据库连接是一个 “重量级” 操作（涉及网络握手、权限验证等），频繁创建和关闭连接会：

- 浪费服务器资源（数据库需维护连接状态）；
- 增加网络开销，降低操作效率；
- 可能触发数据库的 “连接数限制”（PostgreSQL 默认最大连接数有限制）。

### 正确做法（基于 pgx v5+）：

1. **使用连接池（推荐）**：  
   pgx 提供  `pgxpool.Pool`  类型，初始化一次后，可在程序全局复用。池会自动管理连接的创建、复用和销毁。

```go
package main

import (
		"context"
		"log"

		"github.com/jackc/pgx/v5/pgxpool"
)

func main() {
		// 1. 初始化连接池（程序启动时执行一次）
		connStr := "postgres://user:password@localhost:5432/dbname"
		pool, err := pgxpool.New(context.Background(), connStr)
		if err != nil {
				log.Fatalf("无法创建连接池: %v", err)
		}
		defer pool.Close() // 程序退出时关闭池

		// 2. 复用连接池执行操作（多次调用，无需重复创建连接）
		err = queryData(pool)
		if err != nil {
				log.Println("查询失败:", err)
		}

		err = insertData(pool)
		if err != nil {
				log.Println("插入失败:", err)
		}
}

// 函数接收连接池，复用连接
func queryData(pool *pgxpool.Pool) error {
		ctx := context.Background()
		// 从池里获取连接（内部自动复用空闲连接）
		row := pool.QueryRow(ctx, "SELECT name FROM users WHERE id = $1", 1)
		var name string
		return row.Scan(&name)
}

func insertData(pool *pgxpool.Pool) error {
		ctx := context.Background()
		_, err := pool.Exec(ctx, "INSERT INTO users (name) VALUES ($1)", "test")
		return err
}
```

2. **单连接复用（适合简单场景）**：  
   若场景简单（如单线程脚本），也可创建一个  `pgx.Conn`  连接，复用它执行所有操作，最后关闭。

```go
import (
		"context"
		"log"

		"github.com/jackc/pgx/v5"
)

func main() {
		// 1. 创建单个连接（程序启动时一次）
		conn, err := pgx.Connect(context.Background(), "postgres://user:password@localhost:5432/dbname")
		if err != nil {
				log.Fatalf("无法连接: %v", err)
		}
		defer conn.Close(context.Background()) // 退出时关闭

		// 2. 复用该连接执行多次操作
		_, err = conn.Exec(context.Background(), "INSERT INTO users (name) VALUES ($1)", "a")
		_, err = conn.Exec(context.Background(), "INSERT INTO users (name) VALUES ($1)", "b")
}
```

### 注意事项：

- 连接池需合理配置（如最大连接数  `max_connections`），避免池过大导致数据库压力过高（可在连接字符串中设置，如  `?pool_max_conns=20`）。
- 从池获取的连接无需手动关闭，`pgxpool`  会自动回收。
- 长时间不使用的连接可能被数据库主动关闭，`pgxpool`  会自动检测并重建连接，无需手动处理。

简言之：**一次初始化，全局复用**（通过连接池或单连接），避免重复创建连接。
