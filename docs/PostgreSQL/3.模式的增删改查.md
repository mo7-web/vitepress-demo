# 模式 (Schema)

在 PostgreSQL 中，“模式（Schema）” 是一个非常实用的逻辑概念，理解它可以从 “分类容器” 的角度切入，结合实际场景会更清晰。

### 一句话概括：模式是数据库内的 “文件夹”

如果把  **数据库（Database）**  比作一个 “硬盘分区”，那么  **模式（Schema）**  就像这个分区里的 “文件夹”，而表、视图、函数等数据库对象则是 “文件夹里的文件”。

- 一个数据库（分区）可以有多个模式（文件夹）；
- 模式内可以存放表、视图等对象（文件）；
- 不同模式中可以有同名的对象（比如两个文件夹里都能有 “README.txt”）。

### 模式的核心作用：解决 “命名冲突” 和 “逻辑隔离”

实际开发中，一个数据库往往需要承载多个功能模块（如电商系统的 “订单”“用户”“商品” 模块），或供多个用户 / 团队共同使用。此时，模式的价值就体现出来了：

#### 1. 避免命名冲突

假设开发一个学校管理系统，“学生” 模块和 “教师” 模块都需要一张 “info” 表（存储基本信息）。如果直接放在数据库的默认位置（public 模式），会因 “表名重复” 报错。

但用模式隔离后：

- 创建  `student`  模式，存放  `student.info`  表（学生信息）；
- 创建  `teacher`  模式，存放  `teacher.info`  表（教师信息）；  
   两者名称相同但分属不同模式，不会冲突。

#### 2. 实现逻辑分组

大型项目中，数据库对象可能有成百上千个（表、视图、函数等）。用模式按 “功能” 或 “模块” 分组后，结构会更清晰：

plaintext

```plaintext
school_db（数据库）
├─ student（模式：学生相关）
│  ├─ info（表：学生信息）
│  ├─ score（表：学生成绩）
│  └─ get_avg_score（函数：计算平均分）
├─ teacher（模式：教师相关）
│  ├─ info（表：教师信息）
│  └─ course（表：任教课程）
└─ public（默认模式：公共信息）
   └─ notice（表：学校公告）
```

#### 3. 精细化权限控制

模式可以单独设置权限，比如：

- 让 “学生用户” 只能访问  `student`  模式和  `public`  模式；
- 让 “教师用户” 只能访问  `teacher`  模式和  `public`  模式；
- 拒绝普通用户访问敏感模式（如存放管理员数据的  `admin`  模式）。

### 模式与数据库的区别：不要混淆！

很多人会把 “模式” 和 “数据库” 搞混，两者的核心区别在于：

| 维度     | 数据库（Database）           | 模式（Schema）                      |
| -------- | ---------------------------- | ----------------------------------- |
| 隔离级别 | 完全隔离（默认无法跨库访问） | 同一数据库内共享，可跨模式访问      |
| 连接方式 | 连接时必须指定一个数据库     | 连接数据库后，可切换 / 访问多个模式 |
| 资源占用 | 独立存储，占用更多系统资源   | 共享数据库资源，轻量级              |

### 什么时候需要用模式？

- **多模块 / 多功能系统**：按模块分模式（如订单、支付、用户）；
- **多用户 / 多团队协作**：给每个团队分配独立模式；
- **多租户系统**：用模式隔离不同客户的数据（替代 “一个客户一个数据库” 的重量级方案）；
- **临时对象管理**：创建  `temp`  模式存放临时表，避免污染正式数据。

### 总结

模式本质是数据库内的 “逻辑分组工具”，通过它可以让数据库结构更清晰、避免命名冲突、实现精细化权限控制。对于简单项目，可能用默认的  `public`  模式就够了；但对于中大型项目或多用户场景，合理使用模式会让数据库管理事半功倍。

---

## 模式 (Schema) 的增删改查

### 1. 增加（创建模式）

使用 CREATE SCHEMA 命令创建模式，可指定模式名称、所有者等。

#### 语法：

```sql
-- 基本创建（当前用户为所有者）
CREATE SCHEMA 模式名;

-- 指定所有者（需有对应权限）
CREATE SCHEMA 模式名 AUTHORIZATION 用户名;

-- 若模式已存在，可加 IF NOT EXISTS 避免报错
CREATE SCHEMA IF NOT EXISTS 模式名;
```

#### 示例：

```sql
-- 创建名为 "sales" 的模式
CREATE SCHEMA sales;

-- 创建名为 "mo7_schema" 的模式
CREATE SCHEMA mo7_schema;

-- 创建名为 "hr" 的模式，指定所有者为 user1
CREATE SCHEMA hr AUTHORIZATION user1;
```

### 2. 查询（查看模式）

可通过系统表或 psql 元命令查看模式信息。

#### 方法 1：查询系统表（通用 SQL）

```sql
-- 查看当前数据库所有模式
SELECT schema_name FROM information_schema.schemata;
SELECT * FROM information_schema.schemata;

-- 查看指定模式的所有者
SELECT schema_name, owner FROM information_schema.schemata WHERE schema_name = 'sales';
```

#### 方法 2：psql 元命令（仅在 psql 客户端中使用）

```bash
# 查看所有模式（包括系统模式）
\dS

# 查看模式下的对象（表、视图等）
\dt 模式名.*  -- 查看模式下的表
\dv 模式名.*  -- 查看模式下的视图
```

### 3. 修改（修改模式属性）

主要修改模式的**所有者**或**名称**，使用 ALTER SCHEMA 命令。

#### 语法：

```sql
-- 修改模式所有者
ALTER SCHEMA 模式名 OWNER TO 新用户名;

-- 重命名模式（PostgreSQL 12+ 支持）
ALTER SCHEMA 旧模式名 RENAME TO 新模式名;
```

#### 示例：

```sql
-- 将 "sales" 模式的所有者改为 admin
ALTER SCHEMA sales OWNER TO admin;

-- 将 "hr" 模式重命名为 "human_resources"
ALTER SCHEMA hr RENAME TO human_resources;
```

#### 注意：

- 修改所有者需具备 ALTER 权限或为超级用户。

- 重命名模式不会影响其中的对象（表、函数等），但引用该模式的外部对象（如视图、触发器）可能需要手动更新。

### 4. 删除（删除模式）

使用 DROP SCHEMA 命令删除模式，需注意模式是否包含对象。

#### 语法：

```sql
-- 删除空模式（若有对象则报错）
DROP SCHEMA 模式名;

-- 强制删除模式及其中所有对象（慎用！）
DROP SCHEMA 模式名 CASCADE;

-- 若模式不存在，加 IF EXISTS 避免报错
DROP SCHEMA IF EXISTS 模式名;
```

#### 示例：

```sql
-- 删除空模式 "test_schema"
DROP SCHEMA test_schema;

-- 强制删除 "old_data" 模式及所有下属对象
DROP SCHEMA old_data CASCADE;
```

#### 注意：

- CASCADE 会递归删除模式中的所有对象（表、函数等），操作前务必确认，避免数据丢失！

### 补充：切换默认模式

创建表或查询时，若不指定模式，PostgreSQL 会使用 search_path 配置的默认模式（默认包含 public）。可通过以下命令切换：

```sql
-- 查看当前默认模式
SHOW search_path;

-- 设置默认模式（多个模式用逗号分隔）
SET search_path TO sales, public;  -- 优先使用 sales 模式，再用 public
```

通过以上操作，可完整管理 PostgreSQL 中的模式，实现逻辑隔离和对象组织。
