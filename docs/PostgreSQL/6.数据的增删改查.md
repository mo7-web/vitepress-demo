# 数据的增删改查

在 SQL 中，对表中数据的增删改查（CRUD）是核心操作，对应四个基本命令：`INSERT`（增）、`SELECT`（查）、`UPDATE`（改）、`DELETE`（删）。以下结合具体示例和注意事项进行说明（假设我们有一个名为`users`的表，结构如下，用于演示）：

```sql
-- 示例表结构（PostgreSQL）
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- 自增主键
    name VARCHAR(50) NOT NULL,  -- 姓名（非空）
    email VARCHAR(100) UNIQUE NOT NULL,  -- 邮箱（唯一且非空）
    age INT CHECK (age > 0),  -- 年龄（必须大于0）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- 创建时间（默认当前时间）
);
```

## 一、新增数据（INSERT）

用于向表中插入新记录。

### 基本语法：

```sql
INSERT INTO 表名 (字段1, 字段2, ...)
VALUES (值1, 值2, ...);
```

### 示例：

```sql
-- 1. 插入完整字段数据
INSERT INTO users (name, email, age)
VALUES ('张三', 'zhangsan@example.com', 25);

-- 2. 省略部分字段（使用默认值）
-- 由于created_at有默认值，可省略；id是自增主键，也可省略
INSERT INTO users (name, email)
VALUES ('李四', 'lisi@example.com');  -- age为NULL，created_at用当前时间

-- 3. 批量插入
INSERT INTO users (name, email, age)
VALUES
    ('王五', 'wangwu@example.com', 30),
    ('赵六', 'zhaoliu@example.com', 28);
```

> 错误示例，这里的 users 必须带引号
### 注意事项：

1. **字段与值对应**：字段顺序需与`VALUES`中值的顺序一致，数量必须相同。
2. **数据类型匹配**：值的类型必须与字段定义一致（如`age`是 INT，不能插入字符串）。
3. **约束遵守**：
   - 非空字段（`NOT NULL`）必须提供值（如`name`、`email`）。
   - 唯一约束（`UNIQUE`）字段不能插入重复值（如重复的`email`会报错）。
   - 检查约束（`CHECK`）需满足条件（如`age`不能为负数）。
4. **自增主键**：PostgreSQL 中用`SERIAL`或`IDENTITY`定义自增主键，插入时无需指定（会自动生成）。

## 二、查询数据（SELECT）

用于从表中获取数据，是最常用且复杂的操作。

### 基本语法：

```sql
SELECT 字段1, 字段2, ...  -- 或用*表示所有字段
FROM 表名
[WHERE 条件]  -- 过滤行
[GROUP BY 字段]  -- 分组
[HAVING 分组条件]  -- 过滤分组
[ORDER BY 字段 [ASC|DESC]]  -- 排序（ASC升序，DESC降序）
[LIMIT 数量 OFFSET 偏移量];  -- 限制返回行数
```

### 示例：

```sql
-- 1. 查询所有字段和所有行  users 要带引号
SELECT * FROM users;

-- 2. 查询指定字段
SELECT name, email FROM users;

-- 3. 带条件查询（年龄大于25的用户）
SELECT name, age FROM users WHERE age > 25;

-- 4. 多条件查询（年龄25-30，且姓名含"张"）
SELECT * FROM users
WHERE age BETWEEN 25 AND 30
  AND name LIKE '%张%';  -- %是通配符，匹配任意字符

-- 5. 排序（按年龄降序，相同则按创建时间升序）
SELECT name, age, created_at
FROM users
ORDER BY age DESC, created_at ASC;

-- 6. 限制结果（取前2条）
SELECT * FROM users LIMIT 2;

-- 7. 分页查询（从第3条开始，取2条，即第3-4条）
SELECT * FROM users LIMIT 2 OFFSET 2;
```

### 注意事项：

1. **避免使用`SELECT *`**：实际开发中应明确指定需要的字段，减少数据传输量，避免因表结构变更导致错误。
2. **`WHERE`与`HAVING`区别**：`WHERE`用于过滤行，`HAVING`用于过滤`GROUP BY`后的分组（需配合`GROUP BY`使用）。
3. **`NULL`处理**：`NULL`表示 “未知”，不能用`=`或`!=`判断，需用`IS NULL`或`IS NOT NULL`（如`WHERE age IS NULL`）。
4. **性能优化**：大量数据查询时，合理使用`WHERE`、`ORDER BY`、`LIMIT`减少返回数据量；对查询频繁的字段建立索引。

## 三、修改数据（UPDATE）

用于更新表中已有记录。

### 基本语法：

```sql
UPDATE 表名
SET 字段1 = 值1, 字段2 = 值2, ...
[WHERE 条件];  -- 指定要更新的行（若省略，将更新所有行！）
```

### 示例：

```sql
-- 1. 更新指定行（将张三的年龄改为26）
UPDATE users
SET age = 26
WHERE name = '张三';

-- 2. 同时更新多个字段（修改李四的邮箱和年龄）
UPDATE users
SET email = 'new_lisi@example.com', age = 29
WHERE id = 2;  -- 建议用主键id定位，更精准

-- 3. 基于现有值更新（所有用户年龄加1）
UPDATE users
SET age = age + 1;  -- 无WHERE，会更新所有行！谨慎使用
```

### 注意事项：

1. **必须加`WHERE`**：若省略`WHERE`，将更新表中所有行，可能导致灾难性后果（生产环境中几乎不允许）。
2. **用主键定位**：通过主键（如`id`）定位要更新的行，避免因其他字段重复（如重名）导致误更新。
3. **事务保护**：重要更新操作建议用事务包裹，以便出错时回滚：

```sql
BEGIN;  -- 开始事务
UPDATE users SET age = 30 WHERE id = 1;
-- 确认无误后提交
COMMIT;
-- 若出错，回滚到修改前
-- ROLLBACK;
```

4. **约束检查**：更新后的值仍需满足表的约束（如`email`不能重复，`age`不能为负）。

## 四、删除数据（DELETE）

用于删除表中记录（注意：删除的是记录，不是表结构）。

### 基本语法：

```sql
DELETE FROM 表名
[WHERE 条件];  -- 指定要删除的行（若省略，将删除所有行！）
```

### 示例：

```sql
-- 1. 删除指定行（删除邮箱为zhaoliu@example.com的用户）
DELETE FROM users
WHERE email = 'zhaoliu@example.com';

-- 2. 删除符合条件的多行（删除年龄小于18的用户）
DELETE FROM users
WHERE age < 18;
```

### 注意事项：

1. **慎用无`WHERE`的删除**：`DELETE FROM users;`会删除表中所有记录（但表结构保留），几乎不可逆，务必谨慎。
2. **优先用`WHERE`+ 主键**：精准定位要删除的行，避免误删。
3. **事务保护**：同`UPDATE`，重要删除操作需用事务包裹，允许回滚。
4. **外键约束影响**：若表与其他表有外键关联，删除记录可能受外键约束限制（需先删除关联表的依赖记录，或配置级联删除）。
5. **清空表的替代方案**：若需删除所有记录且表有自增主键，`TRUNCATE TABLE users;`比`DELETE`更高效（但`TRUNCATE`会重置自增序列，且不能回滚）。

## 通用标准与最佳实践

1. **SQL 关键字大写**：虽然 PostgreSQL 不区分大小写，但约定关键字（如`SELECT`、`INSERT`）大写，字段名、表名小写，提高可读性。
2. **使用别名**：复杂查询中用`AS`给表或字段起别名，简化语句：

```sql
SELECT u.name AS 用户名, u.age AS 年龄
FROM users AS u
WHERE u.age > 25;
```

3. **避免硬编码值**：开发中不要直接写死值（如`WHERE id = 1`），而是用参数化查询，防止 SQL 注入。
4. **备份数据**：执行`UPDATE`、`DELETE`前，尤其是批量操作，建议先备份数据或用`SELECT`确认要修改 / 删除的记录。
5. **关注性能**：对大表操作时，避免全表扫描（如无`WHERE`的`UPDATE`/`DELETE`），必要时先测试影响范围。

通过以上示例和注意事项，可以更规范地使用 SQL 进行数据操作，减少错误并提高效率。实际使用中，可结合具体业务场景灵活调整。
