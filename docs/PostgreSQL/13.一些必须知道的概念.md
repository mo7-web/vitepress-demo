# 一些必须知道的概念

## 1. 事务

事务是数据库中**一组不可分割的操作集合**，这组操作要么**全部成功执行并永久生效**，要么**只要其中任何一步失败，所有操作都回滚到初始状态**，以此保证数据始终处于 “一致” 状态。

### 核心目的：

避免 “部分成功、部分失败” 导致的数据混乱。  
比如 “转账” 场景：A 账户扣钱、B 账户加钱，这两步必须同时成功或同时失败 —— 如果只扣了 A 的钱但 B 没加上，数据就错了。事务就是用来解决这种问题的。

### 关键特性（ACID，简单理解）：

- **原子性（Atomic）**：操作要么全成，要么全败（核心）。
- **一致性（Consistent）**：事务结束后，数据必须符合预设规则（比如余额不能为负）。
- **隔离性（Isolated）**：多个事务同时执行时，互不干扰（避免 “脏读” 等问题）。
- **持久性（Durable）**：事务成功后，修改会永久保存（即使数据库崩溃也不丢失）。

简单说：事务就是给 “多步操作” 上了个 “保险”，确保它们作为一个整体 “要么都成，要么都不算数”。

---

除了事务，在实际开发中（尤其是结合 PostgreSQL 和 Go 开发业务时），以下数据库概念和特性是必须了解的，它们直接影响数据设计、查询性能、数据完整性和业务稳定性：

## 2.  索引（Index）

- **作用**：加速查询（类似书籍的目录），避免数据库全表扫描（尤其是表数据量大时）。
- **关键知识**：
  - 常用类型：`B-tree`（默认，适合范围查询、排序）、`Hash`（适合等值查询）、`GIN`（适合数组、JSONB 等复杂类型）、`GiST`（适合地理信息等）。
  - **注意**：
    - 不是越多越好：索引会占用额外存储空间，且  **插入 / 更新 / 删除时会触发索引重建**，拖慢写操作。
    - 适合加索引的场景：频繁作为  `WHERE`、`JOIN`、`ORDER BY`  条件的列（如用户 ID、订单号）。
    - 不适合：数据重复率高的列（如性别，区分度低）、频繁更新的列。

```sql
-- 创建B-tree索引（适合WHERE/ORDER BY）
CREATE INDEX idx_users_country ON users(country); -- 加速按国家查询

-- 创建GIN索引（适合JSONB类型）
CREATE TABLE products (
    id INT PRIMARY KEY,
    attrs JSONB  -- 存储商品属性（如{"color": "red", "size": "L"}）
);
CREATE INDEX idx_products_attrs ON products USING GIN(attrs); -- 加速JSON查询

-- 删除无用索引
DROP INDEX idx_users_country;
```

## 3. 约束（Constraint）

- **作用**：强制保证数据的完整性和合法性，避免脏数据（比应用层校验更可靠，因为数据库是最终存储层）。
- **常用约束**：
  - `PRIMARY KEY`（主键）：唯一标识一行，非空且唯一（一张表只能有一个）。
  - `FOREIGN KEY`（外键）：维护表之间的关联关系（如  `orders`  表的  `user_id`  关联  `users`  表的  `id`），防止 “孤儿数据”（如订单关联了一个不存在的用户）。
  - `UNIQUE`：保证列值唯一（如用户名、手机号，可多个列组合）。
  - `NOT NULL`：列值不能为  `NULL`（如用户的  `name`  不能为空）。
  - `CHECK`：自定义校验规则（如  `age > 0`、`balance >= 0`）。

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY, -- 主键约束（非空+唯一）
    username TEXT UNIQUE NOT NULL, -- 唯一约束+非空约束
    email TEXT CHECK (email LIKE '%@%'), -- 自定义校验（邮箱格式）
    age INT CHECK (age > 0), -- 年龄必须为正数
    country TEXT DEFAULT 'Unknown' -- 默认值（也算一种约束）
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT NOT NULL,
    -- 外键约束（订单必须关联存在的用户）
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE -- 级联删除：用户删了，订单也删
);
```

## 4.  数据类型（Data Types）

- PostgreSQL 提供了极其丰富的数据类型，合理选择能提升性能和可读性：
  - 基础类型：`int4`（32 位整数）、`int8`（64 位整数）、`varchar(n)`（变长字符串，n 限制长度）、`text`（无长度限制字符串）、`timestamp`（时间戳，带时区用  `timestamptz`）。
  - 特色类型：
    - `JSONB`：存储 JSON 数据，支持高效查询（可建 GIN 索引，适合存储半结构化数据，如用户偏好、商品属性）。
    - `array`：数组类型（如  `int[]`、`text[]`，适合存储标签列表等）。
    - `enum`：枚举类型（如订单状态  `('pending', 'paid', 'cancelled')`，限制输入范围）。
- **为什么重要**：选错类型会浪费空间（如用  `int8`  存小数字）或导致数据截断（如用  `varchar(10)`  存长字符串）。

```sql
CREATE TABLE demo_types (
    id INT, -- 32位整数
    big_num INT8, -- 64位整数
    username VARCHAR(50), -- 最长50字符的字符串
    description TEXT, -- 无长度限制的文本
    price DECIMAL(10,2), -- 精确到分的金额（共10位，2位小数）
    create_time timestamptz, -- 带时区的时间戳
    tags TEXT[], -- 字符串数组（如{'tag1', 'tag2'}）
    props JSONB, -- JSON格式数据（可查询）
    status ENUM('active', 'inactive') -- 枚举类型（限制值范围）
);
```

## 5. 视图（View）

- **作用**：虚拟表，由一条  `SELECT`  语句定义，简化复杂查询（尤其多表关联场景）。
- **场景**：
  - 业务中频繁需要 “用户基本信息 + 订单统计” 的组合数据，可定义视图  `user_order_stats`，后续直接查视图即可，无需重复写关联逻辑。
  - 限制数据访问范围（如给部分用户只开放视图，隐藏原始表的敏感字段）。
- **注意**：大部分视图是 “只读” 的（除非定义为可更新视图），修改数据仍需操作原始表。

```sql
-- 创建视图：用户订单统计
CREATE VIEW user_order_stats AS
SELECT
    u.user_id,
    u.username,
    COUNT(o.order_id) AS order_count,
    SUM(o.total_amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.username;

-- 使用视图（像查表一样）
SELECT * FROM user_order_stats WHERE total_spent > 1000;

-- 删除视图
DROP VIEW user_order_stats;
```

## 6.  事务隔离级别（Isolation Levels）

- 事务的 ACID 中 “隔离性” 的具体实现，控制多个并发事务之间的相互影响（避免脏读、不可重复读、幻读）。
- PostgreSQL 支持 4 种隔离级别（默认是  `READ COMMITTED`）：
  - `READ UNCOMMITTED`：最低级别，可能读到未提交的 “脏数据”（PostgreSQL 中实际表现和  `READ COMMITTED`  一样，不会脏读）。
  - `READ COMMITTED`（默认）：只能读到已提交的数据，避免脏读，但可能出现 “不可重复读”（同一事务内两次查询结果不同）。
  - `REPEATABLE READ`：同一事务内多次查询结果一致，避免不可重复读，但可能出现 “幻读”（新增数据被读到）。
  - `SERIALIZABLE`：最高级别，完全隔离，避免所有并发问题，但性能最差（适合严格要求数据一致性的场景）。
- **开发中需注意**：根据业务并发场景选择级别（如金融交易可能需要  `REPEATABLE READ`  或更高）。

```sql
-- 设置事务隔离级别（需在事务开始前设置）
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 设置为可重复读
-- 执行SQL操作...
COMMIT;

-- pgx中设置（Go代码）
tx, err := dbPool.BeginTx(ctx, pgx.TxOptions{
    I solationLevel: pgx.RepeatableRead,
})
```

## 7. 锁（Locks）

- 数据库在并发操作时保证数据一致性的机制，避免冲突（如两个事务同时修改同一行）。
- **常见锁类型**：
  - 行级锁：只锁定某一行（如  `UPDATE users SET balance=100 WHERE id=1`  会锁定  `id=1`  的行，其他事务可操作其他行）。
  - 表级锁：锁定整个表（如  `ALTER TABLE`  会加表锁，期间其他事务无法读写）。
- **风险**：不当使用会导致死锁（如事务 1 锁行 A 等行 B，事务 2 锁行 B 等行 A），开发中需避免长事务持有锁，或按固定顺序操作资源。

```sql
-- 手动加行锁（FOR UPDATE：锁定查询的行，防止其他事务修改）
BEGIN;
-- 查询并锁定ID=1的产品（其他事务修改该行会阻塞，直到本事务提交）
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
-- 执行更新
UPDATE products SET stock_quantity = stock_quantity - 1 WHERE product_id = 1;
COMMIT;
```

## 8.  数据库范式（Normalization）

设计表结构时的规范，目的是  **减少数据冗余**  和  **避免更新异常**。
核心范式：

1. 1NF（第一范式）：列不可再分

- **要求**：表中所有列的值都是 “原子的”（不可再拆分）。
- **反例**：在  `users`  表中用一个  `address`  列存 “中国 - 北京 - 朝阳区”，这个列可以拆分为  `country`、`city`、`district`，不符合 1NF。

正确示例

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name TEXT,
    country TEXT,  -- 拆分成独立列
    city TEXT,
    district TEXT
);
```

2. 2NF（第二范式）：消除 “部分依赖”

- **前提**：满足 1NF，且表必须有 “复合主键”（多个列组成的主键）。
- **要求**：非主键列必须完全依赖 “整个主键”，而不是依赖主键的一部分（部分依赖）。
- **反例**：订单明细表  `order_items`  用  `(order_id, product_id)`  作为复合主键，但表中存了  `order_date`（订单日期），`order_date`  只依赖  `order_id`（主键的一部分），不依赖整个主键，不符合 2NF。
- **正确设计**：`order_date`  应放在  `orders`  表（依赖  `order_id`），`order_items`  只存与 “订单项” 直接相关的字段：

```sql
-- 订单表（存订单级信息）
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    order_date DATE,  -- 属于订单本身的信息
    user_id INT
);

-- 订单项表（存订单项信息，依赖复合主键）
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id), -- 复合主键
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);
```

3. 3NF（第三范式）：消除 “传递依赖”

- **前提**：满足 2NF。
- **要求**：非主键列之间不能有依赖关系（即非主键列必须直接依赖主键，不能间接依赖）。
- **反例**：`orders`  表中存  `user_id`、`username`，`username`  依赖  `user_id`（而非直接依赖  `order_id`  主键），形成 “`order_id` → `user_id` → `username`” 的传递依赖，不符合 3NF。
- **正确设计**：`username`  只存于  `users`  表，`orders`  表通过  `user_id`  关联查询即可：

```sql
-- 用户表（存用户信息）
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username TEXT  -- 只在这里存一次
);

-- 订单表（只存用户ID，不存用户名）
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT REFERENCES users(user_id), -- 关联用户表
    order_date DATE
);

-- 查询时通过JOIN获取用户名
SELECT o.order_id, u.username
FROM orders o
JOIN users u ON o.user_id = u.user_id;
```

- **反范式**：实际开发中可能为了查询性能故意冗余部分数据（如订单表存一份用户名，避免关联查询），需权衡。

```sql
-- 用户表（1NF：列不可拆；3NF：无传递依赖）
CREATE TABLE users (user_id INT PRIMARY KEY, username TEXT, country TEXT);

-- 产品表
CREATE TABLE products (product_id INT PRIMARY KEY, name TEXT, price DECIMAL(10,2));

-- 订单表（2NF：非主键列完全依赖order_id；3NF：无传递依赖）
CREATE TABLE orders (order_id INT PRIMARY KEY, user_id INT REFERENCES users(user_id), order_date DATE);

-- 订单项表（2NF：复合主键，非主键列依赖整个主键）
CREATE TABLE order_items (
    order_id INT REFERENCES orders(order_id),
    product_id INT REFERENCES products(product_id),
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

## 9.  备份与恢复

- 数据安全的基础，避免意外删除、硬件故障导致数据丢失。
- PostgreSQL 常用工具：
  - `pg_dump`：导出数据库快照（可备份整个库、单个表或查询结果）。
  - `pg_restore`：恢复  `pg_dump`  导出的备份。
- **最佳实践**：定时自动备份（如每天凌晨），并测试恢复流程（避免备份文件损坏）。

```bash
# 备份整个数据库（终端命令）
pg_dump -U username -d ecommerce_test -f backup.sql

# 恢复数据库
psql -U username -d ecommerce_test -f backup.sql

# 只备份users表
pg_dump -U username -d ecommerce_test -t users -f users_backup.sql
```

## 10. 执行计划（Execution Plan）

- 数据库执行查询时的 “操作步骤”（如是否用索引、是否全表扫描、join 方式等）。
- 如何查看：用  `EXPLAIN`  或  `EXPLAIN ANALYZE`  前缀（如  `EXPLAIN ANALYZE SELECT * FROM users WHERE age > 30`）。
- **作用**：分析慢查询的原因（如没走索引、join 顺序不合理），是性能优化的核心工具。

```sql
-- 查看查询执行计划（不实际执行）
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 'completed';

-- 查看执行计划并实际执行（显示耗时）
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 1 AND status = 'completed';
```

## 11. 连接池配置

- 结合你用的  `jackc/pgx`，连接池参数直接影响性能：
  - `max_conns`：最大连接数（不宜过大，PostgreSQL 默认最大连接数是 100，超过会报错）。
  - `min_conns`：最小空闲连接数（避免频繁创建连接）。
  - `max_idle_time`：空闲连接最大存活时间（释放长期不用的连接）。
- 配置原则：根据服务器性能和并发量调整（如 20-50 个连接对中小型应用足够）。

```go
// pgx连接池配置（Go代码）
cfg, _ := pgxpool.ParseConfig("postgresql://user:pass@localhost/dbname")
cfg.MaxConns = 20 // 最大连接数
cfg.MinConns = 5 // 最小空闲连接数
cfg.MaxIdleTime = 30 * time.Minute // 空闲连接30分钟后释放
pool, _ := pgxpool.NewWithConfig(ctx, cfg)
```

## 12. SQL 注入（SQL Injection）防范

- 风险：通过拼接用户输入到 SQL 语句中，恶意篡改查询（如  `SELECT * FROM users WHERE username = 'xxx' OR 1=1;`）。
- 解决：**永远使用参数化查询**（pgx 中用  `$1, $2`  占位符），禁止直接拼接字符串。
- 示例（错误 vs 正确）：

```go
// 错误（拼接字符串，有注入风险）
badQuery := fmt.Sprintf("SELECT * FROM users WHERE username = '%s'", userInput)

// 正确（参数化查询）
goodQuery := "SELECT * FROM users WHERE username = $1"
dbPool.QueryRow(ctx, goodQuery, userInput)
```

## 13. NULL 值的特殊性

- NULL 表示 “未知”，不是空字符串或 0，**不能用  `= NULL`  判断**，必须用  `IS NULL`  或  `IS NOT NULL`。
- 示例：

```sql
-- 正确：查询未填写国家的用户
SELECT * FROM users WHERE country IS NULL;

-- 错误：不会返回任何结果（NULL != NULL）
SELECT * FROM users WHERE country = NULL;
```

- 影响：聚合函数（如  `COUNT(*)`  包含 NULL 行，`COUNT(country)`  排除 NULL 行）。

## 14. 分页查询

- 大量数据查询时必须分页（避免一次性返回几万行导致内存溢出）。
- PostgreSQL 用  `LIMIT`（限制返回行数）和  `OFFSET`（跳过前 N 行）实现。
- 示例：查询第 2 页数据（每页 10 条）

```sql
SELECT * FROM products ORDER BY product_id LIMIT 10 OFFSET 10; -- OFFSET = (页码-1)*每页条数
```

## 15. 数据库迁移（Migration）

- 表结构变更（新增字段、修改类型等）必须通过 “迁移脚本” 管理，避免手动改库（多人协作会混乱）。
- Go 常用工具：`golang-migrate/migrate`（支持 PostgreSQL），通过版本化 SQL 脚本记录结构变更。

## 16. 用户与权限管理

- 生产环境绝不能用超级管理员（postgres）直接连接应用，需创建专用用户并限制权限。
- 示例：创建只读用户

```sql
-- 创建用户
CREATE USER app_read_only WITH PASSWORD 'your_password';
-- 授予只读权限
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_read_only;
```

## 17. 时间类型选择

- 优先用  `timestamptz`（带时区的时间戳）而非  `timestamp`，避免跨时区导致时间错乱（PostgreSQL 会自动转换时区）。
- 示例：

```sql
CREATE TABLE logs (
id SERIAL PRIMARY KEY,
event_time timestamptz DEFAULT CURRENT_TIMESTAMP, -- 自动记录带时区的时间
message text
);
```

---

这些概念是 “从会用 SQL 到能设计和优化数据库” 的关键，尤其是索引、约束、执行计划，在实际开发中几乎每天都会用到。
这些示例覆盖了日常开发中 90% 以上的场景，新手可以先模仿使用，再逐步理解背后的原理。重点关注索引、约束、NULL 处理和 SQL 注入防范，这些是最容易踩坑的地方。
